---
title: JVM中的锁优化
date: 2017-07-30 23:50:58
categories: 
	- JVM
tags:
	- JVM
---

JVM中的锁优化学习。

<!--more-->

锁优化包括：自适应自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。

# 自旋锁与自适应自旋

- 互斥同步的阻塞影响性能，挂起和恢复线程需要转入内核态完成。
- 共享数据的锁定只会持续很短时间，在这很短时间内挂起和恢复线程很浪费。

所以可以让后面请求锁的线程不放弃处理器，执行忙循环（自旋）来等待锁的释放，这就是自旋锁。

自旋锁在锁的占用时间很短的情况下，自旋等待效果很好，但是如果锁被长时间占有，自旋就只会消耗处理器资源了。所以自旋等待必须有限度，超过了限定的次数还没有获取到锁，就使用传统的方式挂起线程。

如果固定了自旋次数，JVM中所有的锁都会使用这个次数，对不同的锁有可能不太适用。JDK6引入了自适应自旋，也就是自旋的次数不是固定的，而是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来决定。

如果在同一个锁对象上，自选等待刚刚成功获取锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也很有可能再次成功，就允许自选等待持续更长时间。

如果对于某个锁，自旋很少能成功获取锁，以后要获取这个锁时可能会直接忽略自旋，避免浪费处理器资源。

# 锁消除

JVM在即时编译器运行时，对一些代码中需要进行同步，但是检测到不可能存在共享数据竞争，就可以进行锁消除。

# 锁粗化

JVM检测到有一连串零碎的操作都对同一个对象加锁，就会把锁同步范围粗化到整个操作序列的外部。

# 轻量级锁

JDK6加入的新型锁机制。在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

轻量级锁工作过程：

- 
---
title: JVM中的锁以及锁优化
date: 2017-07-30 23:50:58
categories: 
	- JVM
tags:
	- JVM
---

JVM中的锁优化学习。

<!--more-->

锁优化包括：自适应自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。

# 偏向锁

偏向锁是在无竞争的情况下，取消之前已经取得锁的线程同步操作。当一个锁对象被一个线程获取后，就进入了偏向模式，当同一个线程再次请求这个锁，无需再进行同步操作。

偏向锁工作过程：

- 当一个锁对象第一次被线程获取的时候，JVM会把锁对象头中的锁标志位设置为01，偏向模式设置为1，表示偏向锁模式。同时使用CAS操作把获取到这个锁的线程ID记录到对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入到这个锁相关的同步块时，JVM不再进行任何同步操作。
- 一旦出现另外一个线程尝试获取这个锁，偏向锁模式就立马结束。根据锁对象目前是否处于被锁定的被锁定的状态决定是否撤销偏向模式，撤销后锁标志恢复到未锁定01状态或者轻量级锁00状态，后续操作会按照轻量级锁那样去执行。

当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。

如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。

# 自旋锁与自适应自旋

- 互斥同步的阻塞影响性能，挂起和恢复线程需要转入内核态完成。
- 共享数据的锁定只会持续很短时间，在这很短时间内挂起和恢复线程很浪费。

所以可以让后面请求锁的线程不放弃处理器，执行忙循环（自旋）来等待锁的释放，这就是自旋锁。

自旋锁在锁的占用时间很短的情况下，自旋等待效果很好，但是如果锁被长时间占有，自旋就只会消耗处理器资源了。所以自旋等待必须有限度，超过了限定的次数还没有获取到锁，就使用传统的方式挂起线程。

如果固定了自旋次数，JVM中所有的锁都会使用这个次数，对不同的锁有可能不太适用。JDK6引入了自适应自旋，也就是自旋的次数不是固定的，而是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来决定。

如果在同一个锁对象上，自选等待刚刚成功获取锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也很有可能再次成功，就允许自选等待持续更长时间。

如果对于某个锁，自旋很少能成功获取锁，以后要获取这个锁时可能会直接忽略自旋，避免浪费处理器资源。

# 锁消除

JVM在即时编译器运行时，对一些代码中需要进行同步，但是检测到不可能存在共享数据竞争，就可以进行锁消除。

# 锁粗化

JVM检测到有一连串零碎的操作都对同一个对象加锁，就会把锁同步范围粗化到整个操作序列的外部。

# 轻量级锁

轻量级锁在无竞争情况下使用CAS去消除同步使用的互斥量

JDK6加入的新型锁机制。在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。绝大部分的锁，在整个同步周期都是不存在竞争的，轻量级锁通过CAS操作避免了使用互斥量的开销。如果有竞争的话，除了互斥量的开销还有CAS操作开销，轻量级锁就比重量级锁要慢。

轻量级锁工作过程：

- 代码即将进入同步块的时候，如果此同步对象没有被锁定，锁标志位01状态，JVM会首先在当前线程的栈帧中建立一个锁记录空间，用于存储锁对象目前的Mark Word拷贝。
- 然后JVM使用CAS尝试把对象的Mark Word更新为指向锁记录的指针，如果成功，表示该线程拥有了这个对象的锁，并且对象的Mark Word锁标志位变成00表示轻量级锁。如果操作失败，表示有其他线程竞争这个对象的锁，JVM会先检查对象的Mark Word是否指向当前线程的栈帧，如果是的话，就说明当前已经拥有了这个对象的锁，直接继续同步；否则说明这个锁对象已经被其他线程抢占了。如果出现竞争锁的情况，轻量级锁需要膨胀为重量级锁，锁标志变为10，Mark Word中存储的是指向重量级锁的指针，后面等待锁的线程必须进入阻塞状态。
- 轻量级锁解锁也是使用CAS，如果对象的Mark Word仍然指向线程的锁记录，就使用CAS把对象的Mark Word和线程锁记录中的Mark Word替换回来，如果能够成功，就完成了；如果替换失败，说明有其他线程尝试获取过该锁，在释放锁的同时，唤醒被挂起的线程。



# JVM中使用锁的过程

- 一个普通对象，Mark Word中记录对象的哈希码、GC分代年龄，锁标志位为01，偏向锁模式位为0.
- 当对象被当做同步锁，并且有一个线程抢到了锁，锁标志位还是01，偏向锁模式位为1，前23位记录抢到锁的线程的id，接着是偏向锁时间戳、GC分代年龄，目前是偏向锁模式。
- 当同一个线程再来获取锁，JVM发现锁对象的处于偏向锁模式，Mark Word中线程id是当前线程，说明当前线程持有锁，可以继续执行同步代码。
- 当另外一个线程来获取锁，JVM发现所对象处于偏向锁状态，Mark Word中线程id不是当前线程，当前线程会先使用CAS尝试获取锁，有可能获取成功，因为持有偏向锁的线程不会自动释放偏向锁。如果当前线程抢锁成功，就把锁对象的Mark Word的线程改为当前线程的id，当前线程获取到了偏向锁。
- 如果获取偏向锁抢锁失败，说明锁对象有竞争，偏向锁升级为轻量级锁。JVM会在当前线程的栈帧中创建一个锁记录空间，用来保存锁对象的Mark Word，同时在锁对象的Mark Word中保存指向这个锁记录空间的指针，如果上述操作成功，当前线程抢到了锁，锁标志位修改为00轻量级锁模式，如果失败了，说明有竞争，继续执行下面的步骤。
- 轻量级锁抢锁失败后，JVM会使用自旋锁，当前线程自旋，如果规定的自旋时间内获取到锁，就说明成功获取锁，执行同步代码块，如果自旋不能成功获取，就会升级为重量级锁。
- 自旋不能成功获取锁，锁会升级为重量级锁，锁标志位10，锁对象的MarkWord存储指向重量级锁的指针。后面获取锁的线程都会阻塞。